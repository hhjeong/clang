# 12월 9일 실습 과제 해법

##	2진수를 10진수로 변환하기

### 해결 방법

* 입력을 처음에 문자열로 입력 받는것이 좋음
 * 입력받은 문자열의 길이 `len`을 알아야 함
* `i`번째 문자 `'0'` 혹은 `'1'`은 정수형 상수 `0`, `1`로 변환되야 함
 * 변환 방법: `bin[i]-'0'`
* 맨 뒤자리는 <var>2<sup>0</sup></var> 바로 앞자리는 <var>2<sup>1</sup></var>에 대응
 * 여러가지 방법이 있으나 `for`, `while`반복문을 이용하여 순회
 * 별도의 변수(아래 소스코드에서는 `p`)를 두고, 이를 순회할 때마다 2를 곱하여 자리수에 대응하는 2의 제곱수를 구하게 함

### 소스코드
```c
#include <stdio.h>
#include <string.h>

int main() {
    int i, len, p = 1;
    int total = 0;

    char bin[31];
    scanf("%s", bin);

    len = strlen( bin );
    for( i = len-1 ; i >= 0 ; --i ) {
        total += (int)(bin[i]-'0') * p;
        p *= 2;
    }
    printf("%d\n", total);
    return 0;
}
```

##	이진탐색 구현하기	

### 소스코드
```c
#include <stdio.h>

void binary_search( int A[], int n, int tar ) {
    int lo = 0;
    int hi = n-1;
    int mid;

    while(lo<=hi) {
        mid = (lo+hi) / 2;
        printf("%d %d %d\n", lo, hi, A[mid]);
        if( A[mid] == tar ) {
            return;
        }
        else if( A[mid] < tar ) {
            lo = mid+1;
        }
        else {
            hi = mid-1;
        }
    }
}

int main() {
    int n, i, tar;
    int A[100];

    scanf("%d", &n);

    for( i = 0 ; i < n ; ++i ) scanf("%d", A+i);

    scanf("%d", &tar);

    binary_search( A, n, tar );
}
```

##	홀수 마방진

### 해결 방법

* 문제에 언급한대로, 현재 숫자를 채워야 할 위치의 행과 열을 2개의 변수를 이용해 저장, 이를 변경하여 숫자를 채워나감
* 소스코드는 다음과 같이 나뉘어 구현됨
    1. 지정한 위치에 채워야 할 숫자를 채움
    2. 현재 채운 숫자가 배수일 경우와 아닐경우를 구분하여 새로운 위치를 갱신
    3. 범위를 벗어날 경우에 대해 위치를 새로이 갱신
        * 이 때, `if`문을 이용해 이를 처리한다면 행과 열을 독립적으로 생각해야 조건문의 구조가 깔끔해짐
        * 나머지 연산(`%`)의 특징을 이용해 다음과 같이 구현할 수 있음
            * `i = (i+n) % n`
            * `j = (j+n) % n`

### 소스코드
```c
#include <stdio.h>

int main() {
    int n;
    int i, j, k;
    int S[11][11];

    scanf("%d", &n);

    i = 0;
    j = n/2;

    for( k = 1 ; k <= n * n ; ++k ) {
        S[i][j] = k;

        if( k % n == 0 ) {
            i++;
        }
        else {
            i--;
            j++;
        }

        i = (i+n) % n;
        j = (j+n) % n;
    }

    for( i = 0 ; i < n; ++ i) {
        for( j = 0 ; j < n; ++j ) {
            printf("%4d", S[i][j]);
        }
        printf("\n");
    }
}
```

## 중복된 숫자 제거하기

### 해결방법

1. 배열을 정렬하고, 정렬된 `i`번째 숫자와 `i-1`숫자가 동일한 경우를 전체 숫자의 개수에 대해 빼면 됨  
2. 숫자의 범위가 1이상 1,000이하, 배열의 원소 `F[i]`에 대해 숫자 `i`가 존재할 경우 `1`, 그렇지 않을 경우 `0`으로 표현하고, 배열 내에 1의 개수를 세는 방법으로 구현할 수 있음

### 소스코드

* 두번째 방법에 대한 소스 코드
* 
```c
#include <stdio.h>

int main() {
    int F[1001] = {0};

    int n, i;
    int x, sum = 0;

    scanf("%d", &n);
    for( i = 0 ; i < n ; ++i ) {
        scanf("%d", &x);
        F[x] = 1;
    }

    for( i = 1 ; i <= 1000 ; ++i ) sum += F[i];

    printf("%d\n", sum);
}
```
